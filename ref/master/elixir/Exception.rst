Exception
==============================================================

.. elixir:module:: Exception

   :mtype: 

Overview
--------

Functions to format throw/catch/exit and exceptions.

Note that stacktraces in Elixir are updated on throw, errors and exits.
For example, at any given moment, ``System.stacktrace`` will return the
stacktrace for the last throw/error/exit that ocurred in the current
process.

Do not rely on the particular format returned by the ``format``
functions in this module. They may be changed in future releases in
order to better suit Elixir's tool chain. In other words, by using the
functions in this module it is guarantee you will format exceptions as
in the current Elixir version being used.





Summary
-------

======================================== =
:elixir:func:`exception?/1`              Returns true if the given argument is an exception 

:elixir:func:`format/3`                  Normalizes and formats throw/errors/exits and stacktrace 

:elixir:func:`format_banner/3`           Normalizes and formats any throw, error and exit 

:elixir:func:`format_exit/1`             Formats an exit, returns a string 

:elixir:func:`format_fa/2`               Receives an anonymous function and arity and formats it as shown in stacktraces. The arity may also be a list of arguments 

:elixir:func:`format_file_line/2`        Formats the given file and line as shown in stacktraces. If any of the values are nil, they are omitted 

:elixir:func:`format_mfa/3`              Receives a module, fun and arity and formats it as shown in stacktraces. The arity may also be a list of arguments 

:elixir:func:`format_stacktrace/1`       Formats the stacktrace 

:elixir:func:`format_stacktrace_entry/1` Receives a stacktrace entry and formats it into a string 

:elixir:func:`message/1`                 Gets the message for an exception 

:elixir:func:`normalize/3`               Normalizes an exception, converting Erlang exceptions to Elixir exceptions 
======================================== =



Types
-----

.. elixir:type:: Exception.t/0

   :elixir:type:`t/0` :: %module{__exception__: true}
   

   The exception type (as generated by defexception)
   

.. elixir:type:: Exception.kind/0

   :elixir:type:`kind/0` :: :error | :exit | :throw | {:EXIT, pid}
   

   The kind handled by formatting functions
   

.. elixir:type:: Exception.stacktrace/0

   :elixir:type:`stacktrace/0` :: [:elixir:type:`stacktrace_entry/0`]
   

.. elixir:type:: Exception.stacktrace_entry/0

   :elixir:type:`stacktrace_entry/0` :: {module, function, arity_or_args, location} | {function, arity_or_args, location}
   





Functions
---------

.. elixir:function:: Exception.exception?/1
   :sig: exception?(arg1)


   
   Returns true if the given argument is an exception.
   
   

.. elixir:function:: Exception.format/3
   :sig: format(kind, payload, stacktrace \\ nil)


   Specs:
   
 
   * format(:elixir:type:`kind/0`, any, :elixir:type:`stacktrace/0` | nil) :: :elixir:type:`String.t/0`
 

   
   Normalizes and formats throw/errors/exits and stacktrace.
   
   It relies on ```format_banner/3`` <#format_banner/3>`__ and
   ```format_stacktrace/1`` <#format_stacktrace/1>`__ to generate the final
   format.
   
   Note that ``{:EXIT, pid}`` do not generate a stacktrace though (as they
   are retrieved as messages without stacktraces).
   
   

.. elixir:function:: Exception.format_banner/3
   :sig: format_banner(kind, exception, stacktrace \\ nil)


   Specs:
   
 
   * format_banner(:elixir:type:`kind/0`, any, :elixir:type:`stacktrace/0` | nil) :: :elixir:type:`String.t/0`
 

   
   Normalizes and formats any throw, error and exit.
   
   The message is formatted and displayed in the same format as used by
   Elixir's CLI.
   
   The third argument, a stacktrace, is optional. If it is not supplied
   ```System.stacktrace/0`` <System.html#stacktrace/0>`__ will sometimes be
   used to get additional information for the ``kind`` ``:error``. If the
   stacktrace is unknown and
   ```System.stacktrace/0`` <System.html#stacktrace/0>`__ would not return
   the stacktrace corresponding to the exception an empty stacktrace,
   ``[]``, must be used.
   
   

.. elixir:function:: Exception.format_exit/1
   :sig: format_exit(reason)


   Specs:
   
 
   * format_exit(any) :: :elixir:type:`String.t/0`
 

   
   Formats an exit, returns a string.
   
   Often there are errors/exceptions inside exits. Exits are often wrapped
   by the caller and provide stacktraces too. This function formats exits
   in a way to nicely show the exit reason, caller and stacktrace.
   
   

.. elixir:function:: Exception.format_fa/2
   :sig: format_fa(fun, arity)


   
   Receives an anonymous function and arity and formats it as shown in
   stacktraces. The arity may also be a list of arguments.
   
   **Examples**
   
   ::
   
       Exception.format_fa(fn -> end, 1)
       #=> "#Function<...>/1"
   
   
   

.. elixir:function:: Exception.format_file_line/2
   :sig: format_file_line(file, line)


   
   Formats the given file and line as shown in stacktraces. If any of the
   values are nil, they are omitted.
   
   **Examples**
   
   ::
   
       iex> Exception.format_file_line("foo", 1)
       "foo:1:"
   
       iex> Exception.format_file_line("foo", nil)
       "foo:"
   
       iex> Exception.format_file_line(nil, nil)
       ""
   
   
   

.. elixir:function:: Exception.format_mfa/3
   :sig: format_mfa(module, fun, arity)


   
   Receives a module, fun and arity and formats it as shown in stacktraces.
   The arity may also be a list of arguments.
   
   **Examples**
   
   ::
   
       iex> Exception.format_mfa Foo, :bar, 1
       "Foo.bar/1"
   
       iex> Exception.format_mfa Foo, :bar, []
       "Foo.bar()"
   
       iex> Exception.format_mfa nil, :bar, []
       "nil.bar()"
   
   Anonymous functions are reported as -func/arity-anonfn-count-, where
   func is the name of the enclosing function. Convert to "anonymous fn in
   func/arity"
   
   

.. elixir:function:: Exception.format_stacktrace/1
   :sig: format_stacktrace(trace \\ nil)


   
   Formats the stacktrace.
   
   A stacktrace must be given as an argument. If not, the stacktrace is
   retrieved from ```Process.info/2`` <Process.html#info/2>`__.
   
   

.. elixir:function:: Exception.format_stacktrace_entry/1
   :sig: format_stacktrace_entry(entry)


   Specs:
   
 
   * format_stacktrace_entry(:elixir:type:`stacktrace_entry/0`) :: :elixir:type:`String.t/0`
 

   
   Receives a stacktrace entry and formats it into a string.
   
   

.. elixir:function:: Exception.message/1
   :sig: message(exception)


   
   Gets the message for an exception.
   
   

.. elixir:function:: Exception.normalize/3
   :sig: normalize(kind, payload, stacktrace \\ nil)


   Specs:
   
 
   * (normalize(:elixir:type:`kind/0`, payload, :elixir:type:`stacktrace/0`) :: payload) when payload: var
 
   * normalize(:error, any, :elixir:type:`stacktrace/0`) :: :elixir:type:`t/0`
 

   
   Normalizes an exception, converting Erlang exceptions to Elixir
   exceptions.
   
   It takes the ``kind`` spilled by ``catch`` as an argument and normalizes
   only ``:error``, returning the untouched payload for others.
   
   The third argument, a stacktrace, is optional. If it is not supplied
   ```System.stacktrace/0`` <System.html#stacktrace/0>`__ will sometimes be
   used to get additional information for the ``kind`` ``:error``. If the
   stacktrace is unknown and
   ```System.stacktrace/0`` <System.html#stacktrace/0>`__ would not return
   the stacktrace corresponding to the exception an empty stacktrace,
   ``[]``, must be used.
   
   







